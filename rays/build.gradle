//
//
//
//
// TO COMPILE TEST RESULTS FROM ALL SUBPROJECTS
// gradle allTests
//
//
// TO GENERATE BASE DB SCHEMAS (HSQLDB,MySQL) FOR :frontend
// gradle :frontend:generateSchema
//
//
// TO BUILD DOCKER IMAGES:
//
// ./gradlew docker dockerTag
//     OR
// ./gradlew :worker:docker :worker:dockerTag :frontend:docker :frontend:dockerTag
//
//
// TO GENERATE docker-compose.yml FILE FROM ITS TEMPLATE
// gradle generateDockerCompose
//
//
// TO START docker-compose.yml CONFIGURATION
// docker-compose up --d --scale worker=[WORKER-COUNT]
//

buildscript {
	ext { springBootVersion = '2.1.6.RELEASE' }
	repositories { mavenCentral() }
	dependencies { classpath("org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}") }
}

plugins {
	id 'com.palantir.docker' version '0.20.1' apply false
	id 'com.palantir.docker-compose' version '0.20.1'
	id 'com.google.osdetector' version '1.6.2'
}

group = 'org.snowjak'
version = '0.3'
wrapper { gradleVersion = 4.8 }


project.ext.dockerComposeTemplateName = "docker-compose.yml.template"

if ( file( dockerComposeTemplateName + "." + osdetector.arch ).exists() )
	dockerComposeTemplateName = dockerComposeTemplateName + "." + osdetector.arch


allprojects {
	apply plugin: 'eclipse'
	apply plugin: 'java'
	apply plugin: 'io.spring.dependency-management'
	
	repositories {
		mavenCentral()
		jcenter()
		maven { url "http://maven.vaadin.com/vaadin-addons" }
	}
	
	sourceCompatibility = 11
	
	tasks.withType(JavaCompile) { options.compilerArgs << '-parameters' }
}

subprojects { p ->
	
	p.group = rootProject.group
	p.version = rootProject.version
	
	if( p.name != "core" ) {
		
		apply plugin: 'io.spring.dependency-management'
		apply plugin: 'org.springframework.boot'
		
		if(p.name != "spectrum-generator") {
			apply plugin: 'com.palantir.docker'
			
			
			p.ext.dockerFileName = "Dockerfile"
			
			if ( file( dockerFileName + "." + osdetector.arch ).exists() )
				dockerFileName = dockerFileName + "." + osdetector.arch
			
			
			task copyDataToDockerBuildDir(type: Copy) {
				from 'data/'
				into "$buildDir/docker/data"
				duplicatesStrategy = 'include'
				
				dependsOn 'copyDataFromCore'
				dependsOn 'dockerPrepare'
			}
			
			docker {
				name = "${p.group}/${p.name}:${p.version}"
				dockerfile p.file( dockerFileName )
				tags "latest"
				files p.jar.archivePath
				buildArgs([ JAR_FILE: p.jar.archiveName, DATA_DIR: 'data' ])
				pull true
			}
			
			p.tasks.docker.dependsOn { 'copyDataToDockerBuildDir' }
			
			p.tasks.docker.dependsOn {'bootJar' }
			p.tasks.dockerPush.dependsOn { 'dockerTag' }
		}
		
		clean.delete << file('data/')
		
		task copyDataFromCore(type: Copy) {
			from project(":core").file( "data/")
			into p.file("data/")
			duplicatesStrategy = 'include'
		}
		processResources.dependsOn( copyDataFromCore )
		
		dependencies { compile project(":core") }
		
		clean.dependsOn( project(":core").clean )
		test.dependsOn( project(":core").test )
	}
	
	test.ignoreFailures = true
}

task allTests(type: TestReport) {
	group = "Verification"
	description = "Gathers the output from all subproject 'test' tasks"
	destinationDir = file("$buildDir/reports/allTests/")
	
	dependsOn subprojects.collect( { it.tasks.withType(Test) } ).flatten()
	reportOn subprojects.collect( { it.tasks.withType(Test) } ).flatten()
}

clean.delete << file('build/docker-compose.yml.template.expanded')

task expandDockerComposeTemplate(type: Copy) {
	from dockerComposeTemplateName
	expand( project.properties )
	into 'build'
	rename { "docker-compose.yml.template.expanded" }
	duplicatesStrategy 'INCLUDE'
	
	dependsOn ":worker:docker"
	dependsOn ":frontend:docker"
}

dockerCompose {
	template project.file( "build/docker-compose.yml.template.expanded" )
}

generateDockerCompose {
	dependsOn "expandDockerComposeTemplate"
}
